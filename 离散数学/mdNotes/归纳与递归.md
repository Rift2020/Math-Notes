**归纳与递归**

#### **反证法**

考虑你需要证明 $p\rightarrow q$

反证法即是证明逆否命题：$\neg q\rightarrow \neg p$

通常是假设$\neg q$成立，由一系列公理，定义，引理，证明p必然不可能(比如在$\neg q$成立的前提下，q与$\neg q$矛盾)

即$\neg q\rightarrow \neg p$

#### **数学归纳法**

归纳假设 p(n)为命题(p是predicate的意思)

base case:p(x)成立(x应当是一个整数，通常会是一个自然数)

induction case: 证$p(n)\rightarrow p(n+1)$成立，即p(n)成立时，p(n+1)一定成立

conclusion:p(n)在n>=x时都成立

例子：证明$\sum_{i=1}^{n}=(n+1)n/2$

**tips**(来自mit6.042)：

1.慎重使用"..."这种不明确的表达比如：1,2,3...,n-1,n+1，这可能使你犯错，尤其是n非常小的时候比如n=1,n=2

2.如果你发现你归纳不出来$p(n)\rightarrow p(n+1)$，你可以考虑试着增强你的假设p(n)

#### **强归纳法**(又名第二类数学归纳法)

仅有induction case与数学归纳法不同：证$[p(1)\wedge p(2)\wedge...\wedge p(k)]\rightarrow p(k+1)$，也就是如果前面的都成立，可以证明k+1情形也成立

实际上：<u>强归纳法和数学归纳法是等价的</u>，但一般来说强归纳法更加好用，除非已经看出k与k+1的关系，不然应该**优先考虑强归纳法**。

例子：证明若n是大于1的整数，那么n可以写成素数之积

#### **递归**

**递归定义函数**(就像写一样)

$\sum_{k=0}^n a_k$的递归定义：

第一部分$\sum_{k=0}^0 a_k=a_0$

第二部分$\sum_{k=0}^{n+1}=(\sum_{k=0}^n)+a_{n+1}$

这和递归的代码非常的相符(递归和递归终止条件)，同时你也能感受到它和数学归纳法的奇妙的联系

**递归定义集合与结构**

考虑整数的一个子集S

基础步骤 $3\in S$

递归步骤 若$x\in S$且$y\in S$则$x+y\in S$

递归定义满二叉树

基础步骤：单个顶点属于满二叉树

递归步骤：如果$T_1,T_2$都是满二叉树，那么$T_1\cdot T_2$也是满二叉树，点乘意味着树根r连接着左子树T1和右子树T2。





引申：结构归纳法：可以用来证明某个集合里的所有元素都具有某个特殊性质

这些归纳法都可以推广成广义归纳法(如果集合具有良序性)

